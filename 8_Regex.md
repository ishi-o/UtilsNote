# `Regex`

## 基本介绍

- `Regex`全称`Regular Expression`，译为正则表达式或正规表达式
- `Regex`最常用于文本内容的模糊搜索，旨在使用一系列的语法规则高效地匹配任意文本
- 抽象定义如下：
  - 字母表：由所有可能出现的字符组成的**集合**
  - 串：空串以及字符集中的字符的**组合**
  - 语言：串的集合
  - 正则表达式：经过形式化描述的规则，文本内容(整个语言)经过给定的正则表达式得到匹配结果(语言的子集，称为正规集)
- 正则表达式用一系列简洁的符号来表示语言(字符串集合)的运算：
  - 语言的并(即两边集合的任意元素)：`(r) | (s)`
  - 语言的连接(即在左边集合的任意串后拼接右边集合的任意串)：`(r)(s)`
  - 语言的闭包(即集合中的串出现任意次地连接起来)：`(r)*`
  - 语言的正闭包(即集合中的串出现至少一次地连接起来)：`(r)+`
  
    实际上是一个语法糖，等价于`(r)(r)*`
  - 语言与空串的并(语法糖)，表示集合中的串出现至多一次：`(r)?`
  - 运算的优先级：`* > 连接 > |`
- 在实现上，正则表达式拥有多套标准
  - `POSIX`在制定类`Unix`操作系统的接口时顺带制定了`regex`的标准，`POSIX`标准又分为基础`BRE`与扩展`ERE`两种
  - `Perl`语言经过多次迭代后由于其`regex`功能十分强大好用，出现了`PCRE`标准，可以说它是一套工业标准

## `PCRE`

- `PCRE`全称`Perl Compatible Regular Expressions`，是用`C`编写的兼容`Perl`(一种不再流行的语言)正规式语法的正则表达式库
  
  现在的大多数编程语言的正则表达式库属于`PCRE`派系，因此它也成为了一种标准

### 元字符

- 在实现上，此前所说的`*`、`+`、`?`等由于拥有额外的含义，因此自然地需要区分转义与非转义，这些字符称为**元字符**

  元字符不一定是转义/非转义字符，例如`*`、`+`、`?`等不需要用`\`转义就能表达特殊含义，`b`、`z`等需要用`\`转义才能表达特殊含义
- `.`：匹配除`\n`外的任意字符
- 锚点字符：确定匹配位置，它们是零宽度的断言，仅匹配但**不消耗字符**，可以理解为匹配一个间隙
  - `^`：匹配**一行**的开始位置
  - `$`：匹配**一行**的结束位置
  - `\b`：匹配字母与非字母之间的位置
  - `\B`：匹配字母与字母之间的位置
  - `\G`：匹配上一次匹配结束的位置，用于链式搜索
  - `\A`、`\Z`、`\z`：匹配整个文件的开始、第一行结束、结束
- 量词字符：作用于前面的正则表达式，表示匹配的个数
  - `*`：匹配任意次
  - `?`：匹配至多一次
  - `+`：匹配至少一次
  - `{n}`：匹配恰好`n`次
  - `{n, }`：匹配至少`n`次
  - `{a, b}`：匹配至少`a`次、至多`b`次
  - 惰性匹配：在上述量词后添加`?`，这个匹配项会尽可能少地匹配字符
- 字符组：匹配集合内的**单个**字符
  - `[]`：字符集合应由`[]`括住
  - `-`：在字符集合里，如果被两个字符夹住，则`a-b`表示从`a`到`b`的连续字符

    例如`[a-z]`表示匹配**一个**`a`到`z`的字符
  - `^`：应出现在`[]`内的开始位置，表示反集，匹配不在集合内的单个字符

    例如`[^a-z]`表示匹配一个不是`a`到`z`的字符
- 分组与捕获：
  - `(exp)`：表示对这个`exp`分组，此后使用量词可以重复匹配这一组

    它同时会按顺序存储匹配结果，后续可用`\正整数`或`$正整数`取出匹配到的第`正整数`项
  - `(?:exp)`：仅进行分组而不捕获，减少存储
  - `(?<name>exp)`：
- 在`[]`外、所有`()[]{}.?*+^$`需要用`\`转义才能表示原始字符

  在`[]`内、`^`需要用`\`转义才能表示原始含义

  `\`本身也需要转义才能表示原始含义
